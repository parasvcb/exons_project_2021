readme.md

source the data to proceed, 
get list of human genes and for every such gene, retrieve the data from the NCBI.
supplement such data with their feature records, protein records (single fasta) files.



import modules.retriever
import modules.prediction_assignment_ss
import modules.mappings_refseqProtein
import modules.pfam_files
import modules.cath_files_multi
import modules.ncbia_raw_coods
import modules.structure_refseq
from modules.Classes_exons import Gene as Gene
from modules.Classes_exons import Exon as Exon
from modules.Classes_exons import Transcript as Transcript

import re
import cPickle as pickle
import os
import multiprocessing
import sys
if len(sys.argv) != 2:
	print "enter the corret arguements, object_builder.py followed by aruguments.txt\n, please modify arguements.txt file"
	with open("arguments.txt", "w") as fin:
		fin.write(
		    "OrganismFolder:\tOrganismID:\tPDB_source_dir:\tCommon_files:\t\nCores:\t")
	sys.exit()


def makedir(dirname):
	if not os.path.isdir(dirname):
		os.makedirs(dirname)


'''
Create a organism txid folder
in this keep following in following folders and just pass the addrress of that folder
results and rest files will be created automatically
ask for organism taxid and address of that folder folder having mutual files
create files recursively
Download ensemble data as well as source data
'''

with open("arguments.txt") as fin:
	temp_dat = fin.read().split("\n")
	temp_ele = temp_dat[0].split()
	parent_dir = temp_ele[0].split(":")[1]
	organism = temp_ele[1].split(":")[1]
	struct_repo_dir = temp_ele[2].split(":")[1]
	common_data = temp_ele[3].split(":")[1]
	cores = int(temp_dat[1].split(":")[1])
# import ncbia_events
# import more_itertools as mit
# import numpy as n
int_patt = re.compile(r'^\d+$')

build_structure = 1

pfam_der_writer = "/home/paras/project/protein_splicing/9606/derived_data/domains/pfam/"
cath_der_writer = "/home/paras/project/protein_splicing/9606/derived_data/domains/cath/"
pfam_dir = "/home/paras/exons_analysis/pfam/scann/"
cath_domall_file = "/home/paras/mysql/src/cath/cath-domain-description-file.txt"
sift_db_file = "/home/paras/mysql/src/cath/pdb_chain_uniprot.tsv.gz"

# location needs to be changed
source_data = parent_dir+"source_data/"
derived_data = parent_dir+"derived_data/"

pfam_dir = source_data + "pfam/"
ssp_raw = source_data + "SSP/"
pid_add = source_data + 'Refseq_protein/'
ens_pid = source_data + 'ensemble_data/'
swiss_pid = source_data + 'swissprot_data/'
gene_add = source_data + 'gene_tables/'

cath_domall_file = common_data + "cath-domain-description-file.txt"
sift_db_file = common_data + "pdb_chain_uniprot.tsv.gz"
gene2ens_file = common_data + "gene2ensembl.gz"
gene2go_file = common_data + "gene2go.gz"
tabdelim_alias = common_data + "%s.txt" % organism
cx = common_data + "uniprot_cx_%s.tab.gz" % organism
results_dir = source_data + "results/" % organism

save_structure_dir = derived_data + 'structure_data/PDB_structure_derived_data/'
makedir(save_structure_dir)
stride_reformat_dir = derived_data + "stride_pssm_form/"
makedir(stride_reformat_dir)
pfam_der_writer = derived_data + "domains/pfam/"
makedir(pfam_der_writer)
cath_der_writer = derived_data + "domains/cath/"
makedir(cath_der_writer)
pickle_add = derived_data + "pickles/"
makedir(pickle_add)
ss_exons_dir = derived_data + "exons_wise/ss_exons/"
makedir(ss_exons_dir)
stride_exons_dir = derived_data + "exons_wise/stride_exons/"
makedir(stride_exons_dir)
aaseq_exons_dir = derived_data + "exons_wise/aaseq_exons/"
makedir(aaseq_exons_dir)
faaDir = derived_data + 'structure_data/fasta_file_pdb/'
makedir(faaDir)
lisDir = derived_data + 'structure_data/res_no_pdb/'
makedir(lisDir)
pdb_dir = derived_data + 'structure_data/PDB_structure_derived_data/'
makedir(pdb_dir)

# softwares
stride_location = '/home/paras/stride/stride/./stride'
align_location = '/home/paras/mysql/project1/bin/temp/./align'


def file_pickle_dumper(has, filename):
	with open(filename, "w") as fin:
        pickle.dump(has, fin, protocol=pickle.HIGHEST_PROTOCOL)


def file_loader(filename):
	with open(filename) as fin:
        has = pickle.load(fin)
	return has


def retConFor(func, file_int, args):
	# retConFor=returner_control_forwarder
	# args here is the list of parameters to be passed aheaddto the functions_flow
		has = file_loader(file_int) if os.path.isfile(file_int) else func(*args)
		if not os.path.isfile(file_int):
			file_pickle_dumper(has, file_int)
		return has


def retConForDual(func, file_int1, file_int2, args):
	# retConFor=returner_control_forwarder
	# args here is the list of parameters to be passed aheaddto the functions_flow
	if os.path.isfile(file_int1) and os.path.isfile(file_int2):
		has1 = file_loader(file_int1)
		has2 = file_loader(file_int2)
		return has1, has2
    else:
		has1,has2=func(*args)
		file_pickle_dumper(file_int1,has1)
		file_pickle_dumper(file_int2,has2)
		return has1,has2


def functions_imp():
	has_gene_var = retConFor(retriever.hash_gene_var_list,pickle_add+"has_gene_var_%s.pick" % organism,[gene_add, pid_add])
    has_NCBI_Ensemble_gene = retConFor(mappings_refseqProtein.ensemble_ncbi_genes,pickle_add+"has_NCBI_Ensemble_gene_%s.pick" % organism,\
	[gene2ens_file, organism])
	has_refseq_ens,has_refseq_swiss=retConForDual(mappings_refseqProtein.refseqEnsemble,\
	pickle_add+"has_refseq_ens_%s.pick" % organism, pickle_add+"has_refseq_swiss_%s.pick" % organism,\
	[pid_add, ens_pid, swiss_pid])
	has_gene_description = retConFor(mappings_refseqProtein.gene_description,\
	pickle_add+"has_gene_decription_short_%s.pick" % organism,[gene_add])
	has_gene_go,has_gene_components=retConForDual(mappings_refseqProtein.go_terms_and_cellular_location,\
	pickle_add+"has_gene_gonumbers_%s.pick" % organism,pickle_add+"has_gene_components_%s.pick" % organism,\
	[gene2go_file, organism])
	has_gene_cood = retConFor(retriever.hash_gene_coordinates,pickle_add+"has_gene_cood_%s.pick" % organism,[gene_add, pid_add])
	pfam_fil_has = retConFor(pfam_files.pfam_runner,\
	pickle_add+"pfam_final_has_%s.pick" % organism,[pfam_der_writer, pickle_add, pfam_dir, has_gene_var])
	cath_fil_has = retConFor(cath_files_multi.cath_runner,\
	pickle_add+"cath_final_has_%s.pick" % organism,[pickle_add, cath_domall_file, cath_der_writer, sift_db_file, swiss_pid, struct_repo_dir,
            has_refseq_swiss, has_gene_var])
	prediction_assignment_ss.aaseq(has_gene_cood, pid_add, aaseq_exons_dir)
	has_pi = retConFor(prediction_assignment_ss.principal_isoform,pickle_add+"has_pi_%s.pick" % organism,[has_gene_var, aaseq_exons_dir])
	prediction_assignment_ss.assigner(ssp_raw, pid_add, pid_add, ssp_raw)
    prediction_assignment_ss.ss_to_exons(has_gene_cood, ssp_raw, ss_exons_dir)
    return has_gene_var, has_pi, has_NCBI_Ensemble_gene, has_refseq_ens, \
        has_refseq_swiss, has_gene_description, has_gene_cood, \
        has_gene_go, has_gene_components, pfam_fil_has, cath_fil_has



def functions_flow(has_gene_var,has_gene_cood):
	# has_gene_cood = retConFor(retriever.hash_gene_coordinates,pickle_add+"has_gene_cood_%s.pick" % organism,[gene_add, pid_add])
    # prediction_assignment_ss.assigner(ssp_raw, pid_add, pid_add, ssp_raw)
    # prediction_assignment_ss.ss_to_exons(has_gene_cood, ssp_raw, ss_exons_dir)
    if 1:
        structure_refseq.horse(tabdelim_alias, cx, has_gene_var, faaDir, lisDir,
                               struct_repo_dir, save_structure_dir, pid_add, align_location)
    prediction_assignment_ss.prerequisite_stride(
        stride_location, has_gene_var, pdb_dir, stride_reformat_dir, pid_add)
    prediction_assignment_ss.stride_assigner(
        has_gene_cood, stride_reformat_dir, stride_exons_dir)
	has_var_pdbinfo = retConFor(mappings_refseqProtein.proteins_info_var,\
	pickle_add+"has_var_pdbinfo_%s.pick" % organism,[pdb_dir])
	return has_var_pdbinfo
def stride_sspred(var, template):
    template.sort()
    # template has coding exons
    # print var, template, len(template)
    # print "insdies"
    ss = {}
    st = {}
    # print "hello"
    # try:
    if os.path.isfile(ss_exons_dir+"%s" % var):

        with open(ss_exons_dir+"%s" % var) as fin:
            dat = {i[1]: i[0] for i in pickle.load(fin)}
            # print "dat", len(dat), dat, " insitridesspred"
        for i in template:
            ss[i] = dat[i]
        # old-way
        '''
        with open(ss_exons_dir+"%s" % var) as fin:
            ss = {i[1]: i[0] for i in pickle.load(fin)}
        '''
    else:
        for i in range(0, len(template)):
            ss[template[i]] = "NULL"
    # print "ss", len(ss), ss
    if os.path.isfile(stride_exons_dir+"%s" % var):
        with open(stride_exons_dir+"%s" % var) as fin:
            dat = {i[1]: i[0] for i in pickle.load(fin)}
        for i in template:
            st[i] = dat[i]
    else:
        for i in range(0, len(template)):
            st[template[i]] = "NULL"
    # except Exception as E:
        # print "ERROR: stride_sspred()  :", dat, template, var, E
    # print "returned"
    # print ss, st
    return ss, st


def redef(ssp, sst, exids):
    # print "exids", exids
    ssp_2 = {}
    sst_2 = {}
    exid_2 = {}
    for i in exids:
        if i not in exid_2:
            exid_2[i] = exids[i]
    # KEY IS SPAN AND VALUE IS ID
    for i in ssp:
        ssp_2[exid_2[i]] = ssp[i]
    for i in sst:
        sst_2[exid_2[i]] = sst[i]
    # print ssp_2, sst_2
    return ssp_2, sst_2


# functions_flow()
has_gene_var, has_pi, has_NCBI_Ensemble_gene, has_refseq_ens, has_refseq_swiss, \
    has_gene_description, has_gene_cood, has_gene_go, has_gene_components, pfam_fil_has, cath_fil_has = functions_imp()
# sys.exit()
has_var_pdbinfo=functions_flow(has_gene_var, has_gene_cood)
print "all_done: now exiting"
sys.exit()
# print has_gene_components.values()
# print np.histogram(has_gene_components.values(), bins=[0, 0.5, 0.8, 1.1])

has_objects = {}
c = 0
# print "before main program"
for gene in has_gene_var:
    try:
        print c, gene
        c += 1
        if gene:
                # 37, 103, 27, 199
                # exids = ncbia_events.ncbia(has_gene_var[gene], has_pi[gene], aaseq_exons_dir)
            exids = ncbia_raw_coods.ncbia(
                has_gene_var[gene], has_pi[gene], aaseq_exons_dir)
            # print exids
            # print "exids********"
            # continue
            '''
            keys = exids.keys()
            keys.sort()
            for i in keys:
                print i
                print exids[i]
                print "\n\n"
            '''
            has_exons = {}
            oGens = has_NCBI_Ensemble_gene[gene] if gene in has_NCBI_Ensemble_gene else False
            oLoc = (has_gene_components[gene],
                    True) if gene in has_gene_components else (False, False)
            # ((0-1),Bool) if gene in hash, else, (False, False) 1 is membranous
            oGo = has_gene_go[gene] if gene in has_gene_go else False
            oDes = has_gene_description[gene] if gene in has_gene_description else False
            geneObject = Gene(organism, gene, oGens, oLoc, oDes, oGo)
            translisGene = []
            # print "22"
            '''
            # {((1812, 2108), 'AAPPPPVLMHHGESSQVLHPGNKVTLTCVAPLSGVDFQLRRGEKELLVPRSSTSPDRIFFHLNAVALGDGGHYTCRYRLHDNQNGWSGDSAPVELILSD'): ['500', 1, ((1813, 2109),)]
            '''
            # print has_gene_var[gene]
            for var in has_gene_var[gene]:
                # if var == "NP_116573.1":
                # print var
                with open(aaseq_exons_dir+"%s" % var) as fin:
                    dat = pickle.load(fin)
                # print "dat", dat
                # print var
                ssp, sst = stride_sspred(
                    var, [i[1] for i in dat if i[3] == "C"])
                # print "before_redef", ssp, "ssp"
                '''
                sending here vague id's are givfing vage rsuklts
                send only hash of raw_coods and correspodning genomic id's
                '''
                upd_exids = {
                    mexo[1]: exids[(mexo[1], mexo[0], mexo[3])][0] for mexo in dat}
                # print "updexids", upd_exids
                ssp, sst = redef(ssp, sst, upd_exids)
                # print "redef", ssp
                '''
                    # create and complete the transcript object here only, and add it to the list one by one
                '''
                # print "::33::"
                opistat = True if has_pi[gene] == var else False
                olentrans = len("".join([i[0] for i in dat if i[3] == 'C']))
                oens = has_refseq_ens[var] if var in has_refseq_ens else False
                oswiss = has_refseq_swiss[var] if var in has_refseq_swiss else False
                # print ":2"
                transObject = Transcript(var, opistat, olentrans, oens, oswiss)
                # print "1"
                # oStructure, oStruclen = has_var_pdbinfo[var][0], has_var_pdbinfo[var][1] if var in has_var_pdbinfo else False, False
                # print has_var_pdbinfo[var][0]
                oStructure = has_var_pdbinfo[var][0] if var in has_var_pdbinfo else False
                oStruclen = has_var_pdbinfo[var][1] if var in has_var_pdbinfo else False
                # print oStructure, oStruclen
                # print "2"
                if oStructure:
                    transObject.pdb_info(oStructure, oStruclen)
                transexlis = []
                # print dat, "dat"
                # print ssp
                for miniexons in dat:
                    # print miniexons, "me"
                    non_coding_span = miniexons[1]
                    coding_span = miniexons[2]
                    aaseq = miniexons[0]
                    exStatus = miniexons[3]
                    tupsql = (non_coding_span, aaseq, exStatus)
                    exon_id = exids[tupsql][0]
                    '''
                    print exon_id, non_coding_span
                    print exids[tupsql]
                    print (ssp[exon_id], var) if exon_id in ssp else (
                        None, var), "ssp"
                    '''
                    # print (sst[exon_id], var) if exon_id in sst else (None, var), "sst"

                    # print "ae"
                    # print exon_id
                    if exon_id not in has_exons:
                        has_exons[exon_id] = Exon(
                            id=exon_id, aaseq=aaseq, coding_span=coding_span, nc_span=non_coding_span)
                    # print has_exons, "has_exons"
                    # print "flag"
                    has_exons[exon_id].second_seq(
                        ssp[exon_id], var) if exon_id in ssp else has_exons[exon_id].second_seq(None, var)
                    has_exons[exon_id].stride_seq(
                        sst[exon_id], var) if exon_id in sst else has_exons[exon_id].stride_seq(None, var)
                    # print "????"
                    transexlis += [has_exons[exon_id]]
                transObject.exons(transexlis)
                transObject.intron_status()
                if gene in pfam_fil_has:
                    if var in pfam_fil_has[gene]:
                        transObject.pfam_update(pfam_fil_has[gene][var])
                if gene in cath_fil_has:
                    if var in cath_fil_has[gene]:
                        transObject.cath_update(cath_fil_has[gene][var])
                translisGene += [transObject]
            geneObject.transcripts(translisGene)
            geneObject.exons(has_exons.values())
            geneObject.constitutive_alternate_with_freq()
            # print "right_here"
            # cons_exons_pair = geneObject.connst_togetherness()
            has_objects[gene] = geneObject
            '''
            for trans in geneObject.transcripts:
                key = {ji[0]: ji[1] for ji in trans.personal_ss_list()}
                for i in trans.exons:
                    print i.ID, i.coding_span, i.length, i.seq, key[i]
            '''
    except Exception as E:
        print "ERROR: main()", gene, E
        break
    # if c == 1:
    #    break
print "in main program"
# lis = geneObject.connst_togetherness_coding()
'''
for i in lis:
    print "j", [j.ID for j in i]
for trans in geneObject.transcripts:
    print trans.ID, [ex.ID for ex in trans.exons]
print "out?"
print len(has_objects)
'''

with open(results_dir+"objectsave_%s.pick" % organism, "wb") as fin:
    pickle.dump(has_objects, fin, protocol=pickle.HIGHEST_PROTOCOL)

'''
for i in has_objects:
    print i
    print has_objects[i].description()
print "\n\n\n"
'''
