
# coding: utf-8

# In[14]:
import cPickle as pickle
import sys
if len(sys.argv)!=3:
	print "Please type correct location of results dir having object stored as well as organism id as two different arguements"
	sys.exit()
results_dir_csv = sys.argv[1]
organism_id = sys.argv[2]

source_gene_object = sys.argv[1]+'objectsave_%s.pick'%organism_id

import cPickle as pickle
import re, scipy
import CDF
import numpy as np
import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt
filewriter=open(results_dir_csv+'csv/general/General_stats1.log','w')

def div_fact(num,denom):
	try:
		return round(float(num)/denom,3)	
	except:
		return 0


with open (source_gene_object) as fin:
    has=pickle.load(fin)

def protein_length(has_object,res_dir,fout):
    fout.write("=============>\n")
    fout.write("Principal_isoform_length_information\n")
    all_tup=[]
    has_bins={(0,100):0,(100,250):0,(250,500):0,(500,750):0,(750,1000):0,(1000,3000):0,(3000,7000):0,              (7000,15000):0,(15000,37000):0}
    for i in has:
        j=has[i].PI
        all_tup+=[(has[i].ID,j.seqlen)]
        for key in has_bins:
            if key[0] < j.seqlen <= key[1]:
                has_bins[key] += 1
                break
            if j.seqlen>10000:
                pass
                #print j.ID,has[i].ID
    values = has_bins.values()
    fout.write("\nTotal_genes:%s"%sum(values))
    su = sum(values)
    keys = has_bins.keys()
    with open(res_dir+"csv/general/protein_length_variation_pi.csv", "w") as fin:
        fout.write("\n\tLength_range\tTotal\tFrequency\n")
        fin.write("Length_range,Total,Frequency\n")
        keys.sort()
        for i in keys:
            fin.write("%s,%s,%s\n" %("-".join(map(str,i)), has_bins[i], div_fact(has_bins[i],su)))
            fout.write("\t%s\t%s\t%s\n"%("-".join(map(str,i)),has_bins[i],div_fact(has_bins[i],su)))
protein_length(has,results_dir_csv,filewriter)


# In[17]:


def stats(lis):
    lis=[i for i in lis if i>0]
    #print "1",len(lis),sum(lis),np.max(lis),np.min(lis),round(np.mean(lis),3),round(np.median(lis),3),scipy.stats.mode(lis)[0][0],scipy.stats.mode(lis)[1][0],round(np.std(lis),3)
    try:
    	return "\t".join(map(str,[len(lis),sum(lis),np.max(lis),np.min(lis),round(np.mean(lis),3),round(np.median(lis),3),scipy.stats.mode(lis)[0][0],scipy.stats.mode(lis)[1][0],round(np.std(lis),3)]))
    except: 
	return "\t".join(["False"]*9)

# In[18]:


# fig1: transcripts in a agene
def number_unique_exons(gene_ob):
    exons = [i for i in gene_ob.exons if i.length>0]
    uni_ex = {}
    for i in exons:
        lett = ".".join(i.ID.split(".")[2:])
        uni_ex[lett] = 0
    return len(uni_ex)

def variations(geneob):
    var_gene_dual=[]
    retp1=[]
    retp2=[]
    def internal_transition(trans):
        five_pi=[]
        three_pi=[]
        for i in trans.exons:
            if i.length==0:
                five_pi+=[i]
            else:
                five_pi+=[i]
                break
        for i in trans.exons[::-1]:
            if i.length==0:
                three_pi+=[i]
            else:
                three_pi+=[i]
                break
        return [five_pi,three_pi]
        
    ue=number_unique_exons(geneob)
    has_clu={}
    exons_length_dual=[]
    for transcripts in geneob.transcripts:
        seq=''.join(i.seq for i in transcripts.exons)
        if seq not in has_clu:
            has_clu[seq]=[transcripts]
            exons_length_dual += [
                    (number_unique_exons(transcripts), len(seq))]
        else:
            has_clu[seq]+=[transcripts]
        if transcripts.PI:
            piseq=len(seq)
    var_exons_pergene_dual = (len(has_clu), ue)
    for clusters in has_clu:
        BOTH=0;FIVE=0;THREE=0
        if len(has_clu[clusters])>1:
            refsides=internal_transition(has_clu[clusters][0])
            for j in has_clu[clusters][1:]:
                transsides=internal_transition(j)
                if refsides[0]!=transsides[0] and refsides[1]!=transsides[1]:
                    BOTH+=1
                if refsides[0]!=transsides[0]:
                    FIVE+=1
                if refsides[1]!=transsides[1]:
                    THREE+=1
        retp2+=[(",".join([i.ID for i in has_clu[clusters]]),len(has_clu[clusters]),FIVE,THREE,BOTH)]
        #summ will alays be -1 of total as one is always hunted for thereferenec
    return ([piseq,ue,geneob.detail,exons_length_dual,var_exons_pergene_dual,             [len(has_clu[i]) for i in has_clu],len(has_clu)],retp2)
            #this lis will have UTR per prpteon and teher after niqie proteins

def freq_writer(lis):
    retstr=''
    for i in range(2, 11):
        retstr+="\t%s\t%s\t%s\n" %(i, lis.count(i), div_fact(lis.count(i),len(lis)))
    ti = len([i for i in lis if i > 10])
    retstr+="\t11andMore\t%s\t%s\n" % (ti, div_fact(ti,len(lis)))
    return retstr


def writer(total_transcripts, unique_protein_seq, per_protein_UTR, max_UTR_per_gene, res_dir):
    with open(res_dir+"csv/general/Transcripts_and_UTR_per_gene.csv", "w") as fin:
        fin.write("Count,Category\n")
        for i in total_transcripts:
            fin.write("%s,All_transcripts\n" % i)
        for i in unique_protein_seq:
            fin.write("%s,Varying_Protein\n" % i)
        for i in per_protein_UTR:
            fin.write("%s,UTR_per_protein\n" % i)
        for i in max_UTR_per_gene:
            fin.write("%s,max_UTR_per_gene\n" % i)
            
def transcripts(has,fout):
    RAW_data=''
    RAW_data2=''
    total_transcripts = []
    background_UTR=[]
    unique_protein_seq = []
    CONDITION_GENES = {}
    per_protein_UTR = []
    max_UTR_per_protein = []
    genes_greater_than_3000len = []
    genes_gt1_isf_and_1_exon = []
    var_gene_dual = []
    exoncount_isf_length_allunique = []
    only1isf=0
    per_gene_exons=[]
    FIVETHREEBOTH=[0,0,0]
    for gene in has:
        info=variations(has[gene])
#[pilen,ue,genename,exons_length_dual,var_exons_pergene_dual,total_var,unique_protein]
#[commaspe_variants,len(has_clu[clsters]),FIVE,THREE,BOTH)]
        if info[0][0] <= 3000:
            if info[0][6] > 1:# numbero fo unique transcripts
                if info[0][1] > 1:
                    per_gene_exons+=[info[0][1]]
                    total_transcripts += [sum(info[0][5])]
                    unique_protein_seq += [info[0][6]]
                    CONDITION_GENES[gene] = 1
                    var_gene_dual += [info[0][4]]
                    per_protein_UTR+=info[0][5]
                    max_UTR_per_protein += [max(info[0][5])]
                    for i in info[1]:
                        FIVETHREEBOTH[0]+=i[2]
                        FIVETHREEBOTH[1]+=i[3]
                        FIVETHREEBOTH[2]+=i[4]

                else:
                    genes_gt1_isf_and_1_exon += [(gene,
                                                  info[0][0], info[0][6], info[0][2])]
            else:
                if sum(info[0][5])>1:
                    background_UTR+=info[0][5]
                else:
                    only1isf+=1
    

        else:
            genes_greater_than_3000len += [(gene,info[0][0], info[0][2])]
            #gene,genename,pilen,total_variants,proteinvraints,total_exonsingene
        #print info[0]
        #print info[1]
        RAW_data+='%s\t%s\t%s\t%s\t%s\t%s\n'%(gene,info[0][2],info[0][0],sum(info[0][5]),info[0][6],info[0][1])
        for iteration in info[1]:

            RAW_data2+='%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n'%(gene,info[0][0],info[0][6],info[0][1],iteration[0],                            iteration[1],iteration[2],iteration[3],iteration[4])
            #gene,pilen,transcripts,codingexongene,uniquecluster1var,totalUTR,5'3'both
        #print RAW_data
        #print RAW_data2
        exoncount_isf_length_allunique+=info[0][3]
        #break
            

    special_genes=''
    for i in genes_greater_than_3000len:
        special_genes+="\t%s\n"%("\t".join(map(str, i)))
    str_output="""\n============================>
    ->Total_genes:%s
    ->Total genes with Pi length <=3000 are %s, and above are %s
    ->Their description is as follows
    \tGene\tLength\tName
    %s"""%(len(has),len(has)-len(genes_greater_than_3000len),len(genes_greater_than_3000len),special_genes)
    
    str_output+="""
    -> Gene with PI length less than 3000 aa and only 1 listed isoform including UTR variants
    and exlduing ncRNA and lncRNA are :%s
    -> Genes with more than 1 listed isoform but single unique proein coding are : %s
    -> Genes with atleast two protein coding isoforms and only 1 exon is : %s
    -> Genes with PI len less than 3000 aa and atleast two different protein isoforms are
    :%s, amongst those, with atleast two coding exons are: %s

    >Number of transcripts and fraction of genes
    \tCDS_count\tGeneCount\tFrequency
    %s
    
    ->Number of Exons and fraction of genes
    \tDifferent_exons_count\tGeneCount\tFrequency
    %s
    
    ->Summarising
    \tCategory\tVar_count\tSum\tMax\tMin\tMean\tMedian\tMode\tMode_count\tStddev\n")
    \tAll_transcripts_statistics\t%s
    \tUnique_proteinISF_statistics\t%s
    \tPer_proteinISF_UTR_var\t%s
    \tMax_UTR_var_per_gene\t%s
    \tBackground_per_protein_UTR_var\t%s
    
    Amongst the total UTR variants 5' end got affected %s times, 3' end got affcted in :%s times and 
    both ends got affected in %s times
    
    -->Wilcoxon_ranksums_between background per protein UTR var and per protein Set var\t%s
    -->Wilcoxon_ranksums_between background per protein UTR var and MAx UTR per gene in Set\t%s
    -->Relation and spearman correlation unique protein coding exons in gene and their
    coding different unique isoforms : %s
    -->Relation between number of unique coding exons in a transcript and length of transcrpt: %s
    """%(only1isf,len(background_UTR),len(genes_gt1_isf_and_1_exon), len(total_transcripts)+len(genes_gt1_isf_and_1_exon), len(CONDITION_GENES),\
        freq_writer(unique_protein_seq), freq_writer(per_gene_exons), stats(total_transcripts)\
         ,stats(unique_protein_seq),stats(per_protein_UTR),stats(max_UTR_per_protein), stats(background_UTR),\
        div_fact(FIVETHREEBOTH[0],sum(FIVETHREEBOTH)),div_fact(FIVETHREEBOTH[1],sum(FIVETHREEBOTH)),
        div_fact(FIVETHREEBOTH[2],sum(FIVETHREEBOTH)),\
        str(scipy.stats.ranksums(background_UTR, per_protein_UTR)),\
        str(scipy.stats.ranksums(background_UTR, max_UTR_per_protein)),
        str(scipy.stats.spearmanr(a=[i[0] for i in var_gene_dual], b=[i[1] for i in var_gene_dual])),
        str(scipy.stats.spearmanr(a=[i[0] for i in exoncount_isf_length_allunique],\
                                  b=[i[1] for i in exoncount_isf_length_allunique])))
    
    fout.write("%s\n"%(str_output))
    
    fout.write("\nCSV_files:%s"%'\n'.join([results_dir_csv+'RAW/genewiseinformation1.tab',                                           'RAW/genewiseinformation2_cluster_2.tab']))
    with open(results_dir_csv+"new_condition_genes.pick", "w") as fin:
        pickle.dump(CONDITION_GENES, fin)
    
    
    with open (results_dir_csv+'csv/general/RAW/genewiseinformation1.tab','w') as fin:
        fin.write("Gene\tGeneName\tLengthPI\tTotalVariants\tUniqueProteinVariants\tUniqueCodingExons\n")
        fin.write("%s"%RAW_data)
    with open (results_dir_csv+'csv/general/RAW/genewiseinformation2_cluster_2.tab','w') as fin:
        #gene,pilen,cluster1var,totalUTR,5'3'both
        fin.write("Gene\tLengthPI\tUniqueProteinTranscripts\tCoding_exons_gene\tVariants(,)sep\tTotalUTR\t5'\t3'\tBoth\n")
        fin.write("%s"%RAW_data2)
    df = pd.DataFrame(var_gene_dual,columns=['Transcripts','Exons'])
    reg_plot=sns.jointplot(x=df["Exons"], y=df["Transcripts"], kind='reg',space=0,joint_kws={'line_kws':{'color':'cyan'}})
    reg_plot.ax_joint.legend_.remove()
    reg_plot.savefig(results_dir_csv+"plots/general/transcripts_exons_cond_reg.png")
    
    df1 = pd.DataFrame(exoncount_isf_length_allunique,columns=['Exons','PI_length'])
    reg1_plot=sns.jointplot(x=df1["Exons"], y=df1["PI_length"], kind='reg',space=0, color="g",joint_kws={'line_kws':{'color':'cyan'}})
    reg1_plot.ax_joint.legend_.remove()
    reg1_plot.savefig(results_dir_csv+"plots/general/number_of_exons_and_protein_length_unique_dataset_all.png")
    
    writer(total_transcripts, unique_protein_seq, per_protein_UTR, max_UTR_per_protein, results_dir_csv)

transcripts(has,filewriter)


# In[19]:


with open (results_dir_csv+"new_condition_genes.pick") as fin:
    genes_cond=pickle.load(fin)


# In[20]:


def glob_mem(has,genes_cond,fout):
    has_prop={'Mem':0,'Glob':0,'Inter':0}
    for gene in has:
        if gene in genes_cond:
            val= has[gene].localization[0]
            if val == 1:
                key="Mem"
            elif val == 0:
                key = "Glob"
            else:
                key = 'Inter'
            has_prop[key]+=1

    fout.write("\n\nIn the selected dataset follwing are the types of genes \n%s\n"%has_prop)

glob_mem(has,genes_cond,filewriter)
            


# In[21]:


def principal_isoform(human,fout):
    N=0;X=0
    largest=0;notlargest=0
    Ng=0;Xg=0
    largestG=0;notlargestG=0
    for gene in human:
        if human[gene].PI.ID[0]=='N':
            N+=1
        else:
            X+=1
        ma=max([i.seqlen for i in human[gene].transcripts])
        if human[gene].PI.seqlen==ma:
            largest+=1
        else:
            notlargest+=1
        if gene in genes_cond:
            if human[gene].PI.ID[0]=='N':
                Ng+=1
            else:
                Xg+=1
            if human[gene].PI.seqlen==ma:
                largestG+=1
            else:
                notlargestG+=1
    fout.write("\nIN total set, %s genes have PI as reviewed and %s as model"%(div_fact(N,(N+X)), div_fact(float(X)/(N+X),2)))
    fout.write("\nIN analysed set, %s genes have PI as reviewed and %s as model"%(div_fact(Ng,(Ng+Xg)),div_fact(float(Xg)/(Ng+Xg),2)))
    fout.write("\nIN total set, %s genes have PI as longest"%(div_fact(largest,(largest+notlargest))))
    fout.write("\nIN analysed set, %s genes have PI as longest\n"%(div_fact(largestG,(largestG+notlargestG))))

principal_isoform(has,filewriter)


# THREE CONDITION TO PUT IN PLACE, 
# AtLEAST TWO PROTEIN CODING ISOFORMS
# LENGTH <3000
# CODING_EXONS_MUTS BE atleast TWO always

# In[22]:


'''
This block will read the genes in object, will filter them on the basis of atleast two protein coding different siforms
atleast two proetin coding exons and length of pricinpal soform less than 3000 aa
when that criteria is met, it will ask to change the parameter valeu from unique to varition 
that then will calculate the listed cases on the basis of the unique genomic coods as once instance 
and in latter to count them on the basis of the variation also in those cases

correspsonding data is written into the files also and dispaleys on screen with genral statustucs
'''
def counter(exons,parameter):  
    #fout.write( len(exons),"inside"
    #fout.write( [i.ID for i in exons]
    if parameter == "Unique":
        uni_ex={}
        for i in exons:
            lett=".".join(i.ID.split(".")[2:])
            uni_ex[lett]=0
        #fout.write( len(uni_ex),"len"
        return len(uni_ex)
    else:
        return len(exons)


def writer_and_displayer(res_dir,filename,tot_exons,strict_UTR,strict_Coding,strict_M,dual_funct,                       dual_func_coding,dual_func_noncoding,coding_alternate,noncoding_alternate,                        noncoding_consective,coding_consective,strict_aa_removed,ir_retained_coding,                         ir_retained_noncoding,coding_change_splice_site,noncoding_change_splice_site,
                        majorly_consecutivecoding,majorly_consecutivenoncoding,fout):
    fout.write(filename)
    fout.write("\n=================\nUnique exons count based on genomic coordinates\n")
    fout.write(
        "\tCategory\tVar_count\tSum\tMax\tMin\tMean\tMedian\tMode\tMode_count\tStddev\n")
    fout.write( "\n\tTotal_exons\t%s"%stats(tot_exons))
    fout.write( "\n\tStrict_UTR\t%s"%stats(strict_UTR))
    fout.write( "\n\tStrict_Coding\t%s"%stats(strict_Coding))
    fout.write( "\n\tStrict_M\t%s"%stats(strict_M))
    #fout.write( "\n\tStrict_aa_removed\t%s"%stats(strict_aa_removed))
    fout.write( "\n\tDual_func\t%s"%stats(dual_funct))
    fout.write( "\n\tDual_func_coding\t%s"%stats(dual_func_coding))
    fout.write( "\n\tDual_func_noncoding\t%s"%stats(dual_func_noncoding))
    fout.write( "\n\tCoding_alternate\t%s"%stats(coding_alternate))
    fout.write( "\n\tNon_coding_alternate\t%s"%stats(noncoding_alternate))
    #fout.write( "Coding_change_splice_site\t",stats(coding_change_splice_site) 
    #fout.write( "Noncoding_change_splice_site\t",stats(noncoding_change_splice_site)
    fout.write( "\n\tCoding_consective\t%s"%stats(coding_consective))
    fout.write( "\n\tNoncoding_consecutive\t%s"%stats(noncoding_consective))
    fout.write( "\n\tMajorly_consecutive_coding\t%s"%stats(majorly_consecutivecoding))
    fout.write( "\n\tMajorLY_consecutive_noncoding\t%s"%stats(majorly_consecutivenoncoding))
    fout.write( "\n\tIntron_retained_coding\t%s"%stats(ir_retained_coding))
    fout.write( "\n\tIntron_retained_noncoding\t%s"%stats(ir_retained_noncoding))
    fout.write("\nCSV_file:%s"%res_dir+filename+".csv")
    
    '''
    total alternate noncoding, total constitutive coding, \
    total constitutive non coding  
    '''
    with open(res_dir+"csv/general/"+filename+".csv","w") as fin:
        fin.write("Exons,Category\n")
        for i in tot_exons:
            fin.write("%s,Total\n"%(i))
        for i in strict_UTR:
            fin.write("%s,Strict_NC\n"%(i))
        for i in noncoding_alternate:
            fin.write("%s,A-NC\n"%(i))
        for i in noncoding_consective:
            fin.write("%s,G-NC\n"%(i))
        for i in strict_Coding:
            fin.write("%s,Strict_C\n"%(i))
        for i in coding_alternate:
            fin.write("%s,A-C\n"%(i))
        for i in coding_consective:
            fin.write("%s,G-C\n"%(i))
        '''
        for i in dual_funct:
            fin.write("%s,DF\n"%(i))
        for i in majorly_consecutivecoding:
            fin.write("%s,F_C\n"%(i))
        for i in majorly_consecutivenoncoding:
            fin.write("%s,F-NC\n"%(i))
        '''
        
    
    
def exon_counting(has,res_dir,condition,fout):
    '''
    There will be two sets now
    First: Unique coordinate wise
        1.Total number of all exons?
        2.total number of strict coding exons?
        3.Total strict UTR?
        4.Total strict M and 
        5.Total Strict aa change cases
        6.Total number of dual functioning exons
        7.Total number of aternate exons, coding 
        8.Total number of consectuive exons, coding
        9.Total changein splice sites
        10.Total Coding intron retention cases and non coding such cases 
    Second: Through in all the aa properties
    '''
    tot_exons=[]
    strict_UTR=[]
    strict_Coding=[]
    strict_M=[]
    strict_aa_removed=[]
    dual_funct=[]
    coding_alternate=[]
    coding_consective=[]
    noncoding_alternate=[]
    noncoding_consective=[]
    majorly_consecutivecoding=[]
    majorly_consecutivenoncoding=[]
    dual_func_coding=[]
    dual_func_noncoding=[]
    coding_change_splice_site=[]
    noncoding_change_splice_site=[]
    ir_retained_coding=[]
    ir_retained_noncoding=[]
    PARAMETER="Unique"
    #PARAMETER="Variation"
    filename="Variation_allowed" if PARAMETER == "Variation" else "Unique_Coods"
    output_stats = open("General_stats_fig1.log", "a")
    for gene in has:
        if  gene in condition:
            #fout.write( len(has[gene].exons)
            #fout.write( [i.ID for i in has[gene].exons]
            
            tot_exons+=[counter([i for i in has[gene].exons],PARAMETER)]
            
            strict_UTR+=[counter([i for i in has[gene].exons if re.match(r'^U',i.ID)],PARAMETER)]
            strict_Coding+=[counter([i for i in has[gene].exons if re.match(r'^T',i.ID)],PARAMETER)]
            strict_M+=[counter([i for i in has[gene].exons if re.match(r'^M',i.ID)],PARAMETER)]
            dual_funct+=[counter([i for i in has[gene].exons if re.match(r'^D',i.ID)],PARAMETER)]
            dual_func_coding+=[counter([i for i in has[gene].exons if re.match(r'^D\.[1-n]+',i.ID)],PARAMETER)]
            dual_func_noncoding+=[counter([i for i in has[gene].exons if re.match(r'^D.[-][2]',i.ID)],PARAMETER)]
            coding_alternate+=[counter([i for i in has[gene].exons if re.match(r'^[TD]\.[1-n]+\.A',i.ID)],PARAMETER)]
            noncoding_alternate+=[counter([i for i in has[gene].exons if re.match(r'^[UD]\.[-][2]+\.A',i.ID)],PARAMETER)]
            noncoding_consective+=[counter([i for i in has[gene].exons if re.match(r'^[UD]\.[-][2]+\.G',i.ID)],PARAMETER)]
            coding_consective+=[counter([i for i in has[gene].exons if re.match(r'^[TD]\.[1-n]+\.G',i.ID)],PARAMETER)]
            majorly_consecutivecoding+=[counter([i for i in has[gene].exons if re.match(r'^[TD]\.[1-n]+\.F',i.ID)],PARAMETER)]
            majorly_consecutivenoncoding+=[counter([i for i in has[gene].exons if re.match(r'^[UD]\.[-][2]\.F',i.ID)],PARAMETER)]
            strict_aa_removed+=[counter([i for i in has[gene].exons if re.match(r'^\w\.\-1',i.ID)],PARAMETER)]
            ir_retained_coding+=[counter([i for i in has[gene].exons if re.match(r'^R\:[1-n]',i.ID)],PARAMETER)]
            ir_retained_noncoding+=[counter([i for i in has[gene].exons if re.match(r'^R\:[-][2]',i.ID)],PARAMETER)]
            # coding_change_splice_site+=[counter([i for i in has[gene].exons if re.match(r'^\w\.[1-n]\.[A]\.[1-n]\.[ncb]',i.ID)],PARAMETER)]
            # noncoding_change_splice_site+=[counter([i for i in has[gene].exons if re.match(r'^\w\.[-][2]\.[A]\.[1-n]\.[ncb]',i.ID)],PARAMETER)]

    writer_and_displayer(results_dir_csv,filename,tot_exons,strict_UTR,strict_Coding,strict_M,dual_funct,                       dual_func_coding,dual_func_noncoding,coding_alternate,noncoding_alternate,                        noncoding_consective,coding_consective,strict_aa_removed,ir_retained_coding,                         ir_retained_noncoding,coding_change_splice_site,noncoding_change_splice_site,                        majorly_consecutivecoding,majorly_consecutivenoncoding,fout)

exon_counting(has,results_dir_csv,genes_cond,filewriter)


# In[23]:


def alternate_WEF(has,condition,res_dir,fout):
    has_bins={(0,0.200):0,(0.200,0.400):0,(0.400,0.600):0,(0.600,0.800):0,(0.800,1.001):0}
    vals=[]
    for gene in has:
        if gene in condition:
            for exon in has[gene].exons:
                if re.match(r'^[TMD]\.[1-n]+\.A',exon.ID):
                    vals+=[exon.WEF]
                    
                    for key in has_bins:
                        if key[0] <= exon.WEF < key[1]:
                            has_bins[key] += 1
                            break
    
    #print has_bins
    fout.write("\n\n=============>\n")
    fout.write("Inclusion Frequency of Alternate exons\n")
    with open(res_dir+"csv/general/Alternate_exons_with_SS_WEF.csv", "w") as fin:
        fout.write("\tInclusion_Range\tTotal\tFrequency\n")
        fin.write("Inclusion_Range,Total,Frequency\n")
        su=sum(has_bins.values())
        keys=has_bins.keys()
        keys.sort()
        for i in keys:
            fin.write("%s,%s,%s\n" %("-".join(map(str,i)), has_bins[i], div_fact(has_bins[i],su)))
            fout.write("\n\t%s\t%s\t%s"%("-".join(map(str,i)), has_bins[i], div_fact(has_bins[i],su)))
    fout.write("\nCSV_File:%s"%res_dir+"RAW_Alternate_exons_inclusion_freq.csv")
    with open(res_dir+"csv/general/RAW/Alternate_exons_inclusion_freq.csv", "w") as fin:
        #output_stats.write("\n\tInclusion_Range\tTotal\tFrequency\n\n")
        fin.write("Inclusion_Frequency\n")
        for i in vals:
            fin.write("%s\n" %(i))
            # output_stats.write("\n\t%s\t%s\t%s\n") "-".join(map(str,i)), has_bins[i], round(float(has_bins[i])/su, 2)
    with open (res_dir+"csv/general/CDF_WEF.csv",'w') as fin:
        data=CDF.CDF_String(vals,['WEF','Total','Freq'])
        fin.write("%s"%data)
        
alternate_WEF(has,genes_cond,results_dir_csv,filewriter)


# In[24]:


'''
for removing the bias in analysis of laternate exon, choose only those AE which are prsent in PI
ADD ONE FUNCTION TO GIVE PI
Parent should be callable from Exon itself
'''
def exon_length(has,res_dir,genes_cond,output_stats):
    consecutive_exons=[]
    alternate_exons=[]
    for gene in has:
        if gene in genes_cond:
            alt_ex={}
            for i in has[gene].exons:
                if re.match(r'^[TD]\.[1-n]+\.G',i.ID):
                    consecutive_exons+=[i.length]
                elif re.match(r'^[TD]\.[1-n]+\.A',i.ID):
                    specifier=i.ID.split(".")[3]
                    if specifier not in alt_ex:
                        alt_ex[specifier]=[i.length]
                    else:
                        alt_ex[specifier]+=[i.length]
            if alt_ex:
                for keys in alt_ex:
                    #alternate_exons+=[round(np.mean(alt_ex[keys]),2)]
                    alternate_exons+=alt_ex[keys]
    
    #output_stats = open("General_stats_fig1.log", "a")
    output_stats.write("\n\n=============>\n")
    output_stats.write("Length Comparison of constituive and alternate exons\n")
    output_stats.write("\n\tCategory\tVar_count\tSum\tMax\tMin\tMean\tMedian\tMode\tMode_count\tStddev")
    output_stats.write("\n\tConstitutive_exons\t%s"%stats(consecutive_exons))
    output_stats.write("\n\talternate_exons\t%s"%stats(alternate_exons))
    output_stats.write("\nCSV_File:%s"%res_dir+"length_distribution_exons.csv")
    with open(res_dir+"csv/general/length_distribution_exons.csv","w") as fin:
        fin.write("Length,Category\n")
        for i in consecutive_exons:
            fin.write("%s,Consecutive\n"%(i))
        for i in alternate_exons:
            fin.write("%s,Alternate-Coding\n"%(i))
    #output_stats.close()
   
exon_length(has,results_dir_csv, genes_cond,filewriter)


# In[25]:


def stats_new(lis):
    #print "1",len(lis),sum(lis),np.max(lis),np.min(lis),round(np.mean(lis),3),round(np.median(lis),3),scipy.stats.mode(lis)[0][0],scipy.stats.mode(lis)[1][0],round(np.std(lis),3)
  try:
    return "\t".join(map(str,[len(lis),sum(lis),np.max(lis),np.min(lis),round(np.mean(lis),3),round(np.median(lis),3),scipy.stats.mode(lis)[0][0],scipy.stats.mode(lis)[1][0],round(np.std(lis),3)]))
  except Exception as E:
    return 'False'
def change_in_length(has,res_dir,genes_cond,output_stats):
    change_XP=[]
    change_NP=[]
    change_all=[]
    for gene in has:
        if gene in genes_cond:
            has_seq={}
            pi_seq="".join([j.seq for j in has[gene].PI.exons])
            has_seq[pi_seq]=0
            pi_len=len(pi_seq)
            #print pi_seq
            #break
            for transcripts in has[gene].transcripts:
                seq="".join([j.seq for j in transcripts.exons])
                if seq not in has_seq:
                    has_seq[seq]=0
                    val = div_fact((pi_len - len(seq)),pi_len)
                    if val>90:
                        pass
                        '''
                        print has[gene].detail
                        print pi_len
                        print len(seq)
                        print val
                        '''
                    change_all += [val]
                    if transcripts.ID[0]=="X":
                        change_XP += [val]
                    else:
                        change_NP += [val]
    with open (res_dir+"csv/general/change_in_isoform_length.csv","w") as fin:
        fin.write("ChangeinLength,Type")
        for i in change_NP:
            fin.write("%s,NP\n"%i)
        for i in change_XP:
            fin.write("%s,XP\n"%i)
        for i in change_all:
            fin.write("%s,All\n"%i)
    #output_stats = open("General_stats_fig1.log", "a")
    output_stats.write("\n\n=============>\n")
    output_stats.write("Change in transcript length from principal isoform\n")
    output_stats.write("\n\tCategory\tVar_count\tSum\tMax\tMin\tMean\tMedian\tMode\tMode_count\tStddev")
    output_stats.write("\n\tChangeinNP\t%s"%stats_new(change_NP))
    output_stats.write("\n\tChangeinXP\t%s"%stats_new(change_XP))
    output_stats.write("\n\tChangeinall\t%s"%stats_new(change_all))
    output_stats.write("\nCSV_File:%s"%res_dir+"change_in_isoform_length.csv")
    output_stats.close()
change_in_length(has,results_dir_csv,genes_cond,filewriter)


# In[13]:


'''
Raw_files=
results_dir_csv+'csv/general/RAW/genewiseinformation1.tab'
results_dir_csv+'csv/general/RAW/genewiseinformation1.tab'
res_dir+"csv/general/RAW/Alternate_exons_inclusion_freq.csv"
res_dir+"csv/general/length_distribution_exons.csv"

Raw and plottable= 
res_dir+"csv/general/Transcripts_and_UTR_per_gene.csv"
res_dir+"csv/general/Unique_Coods.csv"
res_dir+"csv/general/length_distribution_exons.csv"
res_dir+"csv/general/change_in_isoform_length.csv"

Plottable_files=
res_dir+"csv/general/Alternate_exons_with_SS_WEF.csv"
#hiotsogram, dont add
res_dir+"csv/general/CDF_WEF.csv"
res_dir+"csv/general/protein_length_variation_pi.csv"
'''

